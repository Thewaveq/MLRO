<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flowchart (Miro-like minimal)</title>
<style>
  :root {
    --grid-bg: #fafafa;
    --grid-dot: #e6e6e6;
    --node-bg: #ffffff;
    --node-border: #e0e0e0;
    --node-shadow: 0 6px 20px rgba(0,0,0,0.08);
    --node-selected: #4c9ffe;
    --port-fill: #1976d2;
    --port-fill-hover: #1565c0;
    --handle-fill: #4c9ffe;
  }

  html, body {
    height: 100%;
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color: #222;
  }

  #toolbar {
    height: 56px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 12px;
    background: #fff;
    position: relative;
    z-index: 10;
  }

  #toolbar button {
    height: 36px;
    padding: 0 12px;
    border-radius: 8px;
    border: 1px solid #ddd;
    background: #fff;
    cursor: pointer;
    transition: box-shadow .15s ease, transform .05s ease;
  }
  #toolbar button:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  #toolbar button:active {
    transform: translateY(1px);
  }

  #board {
    position: relative;
    height: calc(100% - 56px);
    overflow: hidden;
    background:
      radial-gradient(var(--grid-dot) 1px, transparent 1px),
      radial-gradient(var(--grid-dot) 1px, transparent 1px),
      var(--grid-bg);
    background-position: 0 0, 12px 12px, 0 0;
    background-size: 24px 24px, 24px 24px, auto;
    user-select: none;
  }

  #wires {
    position: absolute;
    inset: 0;
    z-index: 0;
  }
  #shapes {
    position: absolute;
    inset: 0;
    z-index: 1;
  }

  .node {
    position: absolute;
    min-width: 120px;
    min-height: 60px;
    background: var(--node-bg);
    border: 1px solid var(--node-border);
    border-radius: 12px;
    box-shadow: var(--node-shadow);
    transition: box-shadow .2s ease, border-color .2s ease;
  }
  .node.selected {
    border-color: var(--node-selected);
    box-shadow: 0 8px 24px rgba(76,159,254,0.25);
  }

  .label {
    position: absolute;
    inset: 10px 12px 10px 12px;
    outline: none;
    cursor: text;
    line-height: 1.3;
  }

  /* Resize handles: corners */
  .handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #fff;
    border: 2px solid var(--handle-fill);
    border-radius: 2px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    transform: translate(-50%, -50%);
    display: none;
    cursor: nwse-resize;
  }
  .node.selected .handle { display: block; }
  .handle.ne { cursor: nesw-resize; }
  .handle.sw { cursor: nesw-resize; }
  .handle.se { cursor: nwse-resize; }

  .handle.nw { left: 0%;  top: 0%; }
  .handle.ne { left: 100%; top: 0%; }
  .handle.sw { left: 0%;  top: 100%; }
  .handle.se { left: 100%; top: 100%; }

  /* Ports: 4 sides, visible on hover/selection */
  .port {
    position: absolute;
    width: 12px;
    height: 12px;
    background: var(--port-fill);
    border: 2px solid #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    opacity: 0;
    pointer-events: auto;
    transition: opacity .15s ease, transform .1s ease, background .15s ease;
  }
  .node:hover .port,
  .node.selected .port { opacity: 1; }
  .port:hover { background: var(--port-fill-hover); transform: translate(-50%, -50%) scale(1.1); }

  .port.top    { left: 50%; top: 0%;    }
  .port.right  { left: 100%; top: 50%;  }
  .port.bottom { left: 50%; top: 100%;  }
  .port.left   { left: 0%;  top: 50%;   }

  /* SVG paths (connectors) */
  .connector {
    stroke: #5a6b8b;
    stroke-width: 2;
    fill: none;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.08));
  }
  .connector.arrow {
    marker-end: url(#arrowhead);
  }
  .connector.temp {
    stroke-dasharray: 6 6;
    opacity: 0.9;
  }
</style>
</head>
<body>
  <div id="toolbar">
    <button id="addBlockBtn">Добавить блок</button>
    <button id="addTwoBtn">Добавить 2 блока и связать</button>
  </div>

  <div id="board">
    <svg id="wires">
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M0,0 L10,4 L0,8 z" fill="#5a6b8b"></path>
        </marker>
      </defs>
    </svg>
    <div id="shapes"></div>
  </div>

<script>
(function() {
  const board = document.getElementById('board');
  const svg = document.getElementById('wires');
  const shapesLayer = document.getElementById('shapes');
  const addBlockBtn = document.getElementById('addBlockBtn');
  const addTwoBtn = document.getElementById('addTwoBtn');

  let nodeIdCounter = 1;
  let edgeIdCounter = 1;
  let zCounter = 10;

  /** @type {Map<number, {id:number, el:HTMLElement, x:number, y:number, w:number, h:number}>} */
  const nodes = new Map();
  /** @type {Map<number, {id:number, from:{nodeId:number, side:string}, to:{nodeId:number, side:string}, path:SVGPathElement}>} */
  const edges = new Map();

  let selectedNodeEl = null;

  const linking = {
    active: false,
    fromPortEl: null,
    tempPath: null
  };

  function createNode(x, y, w = 200, h = 120, text = 'Блок') {
    const id = nodeIdCounter++;
    const el = document.createElement('div');
    el.className = 'node';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.width = w + 'px';
    el.style.height = h + 'px';
    el.dataset.id = String(id);
    el.style.zIndex = String(++zCounter);

    // Label
    const label = document.createElement('div');
    label.className = 'label';
    label.contentEditable = 'true';
    label.textContent = text;
    el.appendChild(label);

    // Resize handles
    ['nw','ne','sw','se'].forEach(dir => {
      const hdl = document.createElement('div');
      hdl.className = 'handle ' + dir;
      hdl.dataset.dir = dir;
      el.appendChild(hdl);
      hdl.addEventListener('mousedown', onResizeStart);
    });

    // Ports
    [
      ['top','top'], ['right','right'], ['bottom','bottom'], ['left','left']
    ].forEach(([cls, side]) => {
      const port = document.createElement('div');
      port.className = 'port ' + cls;
      port.dataset.side = side;
      el.appendChild(port);
      port.addEventListener('mousedown', onPortDragStart);
    });

    shapesLayer.appendChild(el);
    nodes.set(id, { id, el, x, y, w, h });

    // Node interactions
    el.addEventListener('mousedown', onNodeDragStart);
    el.addEventListener('mousedown', setSelectedNode, true);

    return el;
  }

  function setSelectedNode(e) {
    const nodeEl = e.currentTarget;
    if (e.target.closest('.handle') || e.target.closest('.port')) return;
    if (e.target.isContentEditable) return;

    if (selectedNodeEl && selectedNodeEl !== nodeEl) {
      selectedNodeEl.classList.remove('selected');
    }
    selectedNodeEl = nodeEl;
    nodeEl.classList.add('selected');
    nodeEl.style.zIndex = String(++zCounter);
  }

  function clearSelection() {
    if (selectedNodeEl) {
      selectedNodeEl.classList.remove('selected');
    }
    selectedNodeEl = null;
  }

  // Drag node
  function onNodeDragStart(e) {
    const nodeEl = e.currentTarget;
    if (e.button !== 0) return;
    if (e.target.closest('.handle') || e.target.closest('.port')) return;
    if (e.target.isContentEditable) return;

    e.preventDefault();
    const id = Number(nodeEl.dataset.id);
    const node = nodes.get(id);
    const boardRect = board.getBoundingClientRect();
    const startMouse = { x: e.clientX, y: e.clientY };
    const start = { x: node.x, y: node.y };

    function onMove(ev) {
      const dx = ev.clientX - startMouse.x;
      const dy = ev.clientY - startMouse.y;
      const nx = Math.max(0, Math.min(boardRect.width - node.w, start.x + dx));
      const ny = Math.max(0, Math.min(boardRect.height - node.h, start.y + dy));
      node.x = nx;
      node.y = ny;
      nodeEl.style.left = nx + 'px';
      nodeEl.style.top = ny + 'px';
      updateEdgesForNode(node.id);
    }
    function onUp() {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // Resize node
  function onResizeStart(e) {
    e.stopPropagation();
    e.preventDefault();
    const handleEl = e.currentTarget;
    const dir = handleEl.dataset.dir;
    const nodeEl = handleEl.closest('.node');
    const id = Number(nodeEl.dataset.id);
    const node = nodes.get(id);
    const boardRect = board.getBoundingClientRect();
    const startMouse = { x: e.clientX, y: e.clientY };
    const start = { x: node.x, y: node.y, w: node.w, h: node.h };
    const minW = 120, minH = 60;

    function onMove(ev) {
      let dx = ev.clientX - startMouse.x;
      let dy = ev.clientY - startMouse.y;

      let nx = start.x;
      let ny = start.y;
      let nw = start.w;
      let nh = start.h;

      if (dir.includes('e')) {
        nw = Math.max(minW, Math.min(boardRect.width - start.x, start.w + dx));
      }
      if (dir.includes('s')) {
        nh = Math.max(minH, Math.min(boardRect.height - start.y, start.h + dy));
      }
      if (dir.includes('w')) {
        nw = Math.max(minW, start.w - dx);
        nx = start.x + (start.w - nw);
        nx = Math.max(0, Math.min(start.x + start.w - minW, nx));
      }
      if (dir.includes('n')) {
        nh = Math.max(minH, start.h - dy);
        ny = start.y + (start.h - nh);
        ny = Math.max(0, Math.min(start.y + start.h - minH, ny));
      }

      node.x = nx; node.y = ny; node.w = nw; node.h = nh;
      nodeEl.style.left = nx + 'px';
      nodeEl.style.top = ny + 'px';
      nodeEl.style.width = nw + 'px';
      nodeEl.style.height = nh + 'px';
      updateEdgesForNode(node.id);
    }

    function onUp() {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // Port drag to connect
  function onPortDragStart(e) {
    if (e.button !== 0) return;
    e.stopPropagation();
    e.preventDefault();
    const fromPortEl = e.currentTarget;
    linking.active = true;
    linking.fromPortEl = fromPortEl;

    const temp = document.createElementNS('http://www.w3.org/2000/svg','path');
    temp.setAttribute('class', 'connector temp arrow');
    svg.appendChild(temp);
    linking.tempPath = temp;

    function onMove(ev) {
      const p0 = getPortCenter(fromPortEl);
      const p1 = { x: ev.clientX, y: ev.clientY };
      setPathCubic(temp, p0, p1, getSideDir(fromPortEl.dataset.side), null);
    }

    function onUp(ev) {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);

      const targetEl = document.elementFromPoint(ev.clientX, ev.clientY);
      if (targetEl && targetEl.classList && targetEl.classList.contains('port') && targetEl !== fromPortEl) {
        // finalize edge
        const edge = createEdge(fromPortEl, targetEl);
        updateEdge(edge);
      }
      if (linking.tempPath && linking.tempPath.parentNode === svg) {
        svg.removeChild(linking.tempPath);
      }
      linking.active = false;
      linking.fromPortEl = null;
      linking.tempPath = null;
    }

    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  function createEdge(fromPortEl, toPortEl) {
    const fromNodeEl = fromPortEl.closest('.node');
    const toNodeEl = toPortEl.closest('.node');
    const edgeId = edgeIdCounter++;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class', 'connector arrow');
    path.dataset.id = String(edgeId);
    svg.appendChild(path);

    const edge = {
      id: edgeId,
      from: { nodeId: Number(fromNodeEl.dataset.id), side: fromPortEl.dataset.side },
      to: { nodeId: Number(toNodeEl.dataset.id), side: toPortEl.dataset.side },
      path
    };
    edges.set(edgeId, edge);
    return edge;
  }

  function updateEdge(edge) {
    const fromNode = nodes.get(edge.from.nodeId);
    const toNode = nodes.get(edge.to.nodeId);
    const fromPortEl = getPortEl(fromNode.el, edge.from.side);
    const toPortEl = getPortEl(toNode.el, edge.to.side);
    const p0 = getPortCenter(fromPortEl);
    const p1 = getPortCenter(toPortEl);
    setPathCubic(edge.path, p0, p1, getSideDir(edge.from.side), getSideDir(edge.to.side));
  }

  function updateEdgesForNode(nodeId) {
    edges.forEach(edge => {
      if (edge.from.nodeId === nodeId || edge.to.nodeId === nodeId) {
        updateEdge(edge);
      }
    });
  }

  function getPortEl(nodeEl, side) {
    return nodeEl.querySelector(`.port.${side}`);
  }

  function getSideDir(side) {
    switch (side) {
      case 'right': return { x: 1, y: 0 };
      case 'left': return { x: -1, y: 0 };
      case 'top': return { x: 0, y: -1 };
      case 'bottom': return { x: 0, y: 1 };
      default: return { x: 1, y: 0 };
    }
  }

  function getPortCenter(portEl) {
    const boardRect = board.getBoundingClientRect();
    const rect = portEl.getBoundingClientRect();
    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2
    };
  }

  function setPathCubic(pathEl, p0, p1, dir0, dir1) {
    const offset = 50;
    const c1 = { x: p0.x + dir0.x * offset, y: p0.y + dir0.y * offset };
    let useDir1 = dir1;
    if (!useDir1) {
      // Guess target direction to make decent temporary curves
      const dx = p1.x - p0.x, dy = p1.y - p0.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        useDir1 = { x: dx > 0 ? -1 : 1, y: 0 };
      } else {
        useDir1 = { x: 0, y: dy > 0 ? -1 : 1 };
      }
    }
    const c2 = { x: p1.x + useDir1.x * offset, y: p1.y + useDir1.y * offset };
    const d = `M ${p0.x},${p0.y} C ${c1.x},${c1.y} ${c2.x},${c2.y} ${p1.x},${p1.y}`;
    pathEl.setAttribute('d', d);
  }

  // Click-empty to clear selection
  board.addEventListener('mousedown', (e) => {
    if (e.target === board || e.target === svg) {
      clearSelection();
    }
  });

  // Buttons
  addBlockBtn.addEventListener('click', () => {
    const { width, height } = board.getBoundingClientRect();
    const x = Math.floor(60 + Math.random() * (width - 260));
    const y = Math.floor(60 + Math.random() * (height - 220));
    const el = createNode(x, y);
    const id = Number(el.dataset.id);
    const node = nodes.get(id);
    node.x = x; node.y = y; node.w = el.offsetWidth; node.h = el.offsetHeight;
  });

  addTwoBtn.addEventListener('click', () => {
    const { width, height } = board.getBoundingClientRect();
    const n1El = createNode(120, 120, 220, 120, 'Начало');
    const n2El = createNode(Math.min(width - 360, 520), Math.min(height - 260, 280), 240, 140, 'Действие');
    const n1 = nodes.get(Number(n1El.dataset.id));
    const n2 = nodes.get(Number(n2El.dataset.id));
    n1.x = 120; n1.y = 120; n1.w = n1El.offsetWidth; n1.h = n1El.offsetHeight;
    n2.x = Math.min(width - 360, 520);
    n2.y = Math.min(height - 260, 280);
    n2.w = n2El.offsetWidth; n2.h = n2El.offsetHeight;

    const from = n1El.querySelector('.port.right');
    const to = n2El.querySelector('.port.left');
    const e = createEdge(from, to);
    updateEdge(e);
  });

  // Init sample
  addTwoBtn.click();
})();
</script>
</body>
</html>
