<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flowchart Dark (Miro-like minimal)</title>
<style>
  :root {
    --grid-bg: #0f1115;
    --grid-dot: #222736;
    --node-bg: #171b24;
    --node-border: #2a3142;
    --node-shadow: 0 10px 30px rgba(0,0,0,0.45);
    --node-selected: #7aa2f7;
    --port-fill: #7aa2f7;
    --port-fill-hover: #9ab8ff;
    --handle-fill: #7aa2f7;
    --text: #e6e9ef;
    --muted: #9aa4b2;
    --wire: #8aa2c6;
  }

  html, body {
    height: 100%;
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color: var(--text);
    background: var(--grid-bg);
  }

  #toolbar {
    height: 56px;
    border-bottom: 1px solid #1b2130;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 12px;
    background: #121622;
    position: relative;
    z-index: 10;
  }

  #toolbar button {
    height: 36px;
    padding: 0 12px;
    border-radius: 8px;
    border: 1px solid #2a3142;
    background: #171b24;
    color: var(--text);
    cursor: pointer;
    transition: box-shadow .15s ease, transform .05s ease, background .15s ease, border-color .15s ease;
  }
  #toolbar button:hover {
    background: #1b2130;
    border-color: #3a4359;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  }
  #toolbar button:active {
    transform: translateY(1px);
  }

  #board {
    position: relative;
    height: calc(100% - 56px);
    overflow: hidden;
    background:
      radial-gradient(var(--grid-dot) 1px, transparent 1px),
      radial-gradient(var(--grid-dot) 1px, transparent 1px),
      var(--grid-bg);
    background-position: 0 0, 12px 12px, 0 0;
    background-size: 24px 24px, 24px 24px, auto;
    user-select: none;
  }

  #wires {
    position: absolute;
    inset: 0;
    z-index: 0;
  }
  #shapes {
    position: absolute;
    inset: 0;
    z-index: 1;
  }

  .node {
    position: absolute;
    min-width: 120px;
    min-height: 60px;
    background: var(--node-bg);
    border: 1px solid var(--node-border);
    border-radius: 12px;
    box-shadow: var(--node-shadow);
    transition: box-shadow .2s ease, border-color .2s ease;
  }
  .node.selected {
    border-color: var(--node-selected);
    box-shadow: 0 14px 40px rgba(122,162,247,0.2);
  }

  .label {
    position: absolute;
    inset: 10px 12px 10px 12px;
    outline: none;
    cursor: text;
    line-height: 1.3;
    color: var(--text);
  }

  /* Resize handles: corners */
  .handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #0f1115;
    border: 2px solid var(--handle-fill);
    border-radius: 2px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.4);
    transform: translate(-50%, -50%);
    display: none;
    cursor: nwse-resize;
  }
  .node.selected .handle { display: block; }
  .handle.ne { cursor: nesw-resize; }
  .handle.sw { cursor: nesw-resize; }
  .handle.se { cursor: nwse-resize; }

  .handle.nw { left: 0%;  top: 0%; }
  .handle.ne { left: 100%; top: 0%; }
  .handle.sw { left: 0%;  top: 100%; }
  .handle.se { left: 100%; top: 100%; }

  /* Ports: 4 sides, visible on hover/selection */
  .port {
    position: absolute;
    width: 12px;
    height: 12px;
    background: var(--port-fill);
    border: 2px solid #0f1115;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    opacity: 0;
    pointer-events: auto;
    transition: opacity .15s ease, transform .1s ease, background .15s ease;
  }
  .node:hover .port,
  .node.selected .port { opacity: 1; }
  .port:hover { background: var(--port-fill-hover); transform: translate(-50%, -50%) scale(1.1); }

  .port.top    { left: 50%; top: 0%;    }
  .port.right  { left: 100%; top: 50%;  }
  .port.bottom { left: 50%; top: 100%;  }
  .port.left   { left: 0%;  top: 50%;   }

  /* SVG paths (connectors) */
  .connector {
    stroke: var(--wire);
    stroke-width: 3;
    fill: none;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,0.35));
    stroke-linejoin: round; /* rounded corners at 90deg bends */
    stroke-linecap: round;
    pointer-events: none; /* do not block port picking */
  }
  .connector.arrow {
    marker-end: url(#arrowhead);
  }
  .connector.temp {
    stroke-dasharray: 6 6;
    opacity: 0.9;
  }
</style>
</head>
<body>
  <div id="toolbar">
    <button id="addBlockBtn">Добавить блок</button>
    <button id="addTwoBtn">Добавить 2 блока и связать</button>
  </div>

  <div id="board">
    <svg id="wires">
      <defs>
        <marker id="arrowhead" markerWidth="12" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M0,0 L12,5 L0,10 z" fill="var(--wire)"></path>
        </marker>
      </defs>
    </svg>
    <div id="shapes"></div>
  </div>

<script>
(function() {
  const GRID = 24; // сетка 24px
  const ELBOW = 28; // отступ для выхода/входа от порта

  const board = document.getElementById('board');
  const svg = document.getElementById('wires');
  const shapesLayer = document.getElementById('shapes');
  const addBlockBtn = document.getElementById('addBlockBtn');
  const addTwoBtn = document.getElementById('addTwoBtn');

  let nodeIdCounter = 1;
  let edgeIdCounter = 1;
  let zCounter = 10;

  /** @type {Map<number, {id:number, el:HTMLElement, x:number, y:number, w:number, h:number}>} */
  const nodes = new Map();
  /** @type {Map<number, {id:number, from:{nodeId:number, side:string}, to:{nodeId:number, side:string}, path:SVGPathElement}>} */
  const edges = new Map();

  let selectedNodeEl = null;

  const linking = {
    active: false,
    fromPortEl: null,
    tempPath: null
  };

  function snapToGrid(value) {
    return Math.round(value / GRID) * GRID;
  }

  function createNode(x, y, w = 200, h = 120, text = 'Блок') {
    x = snapToGrid(x); y = snapToGrid(y);
    w = Math.max(120, snapToGrid(w)); h = Math.max(60, snapToGrid(h));

    const id = nodeIdCounter++;
    const el = document.createElement('div');
    el.className = 'node';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.width = w + 'px';
    el.style.height = h + 'px';
    el.dataset.id = String(id);
    el.style.zIndex = String(++zCounter);

    const label = document.createElement('div');
    label.className = 'label';
    label.contentEditable = 'true';
    label.textContent = text;
    el.appendChild(label);

    ['nw','ne','sw','se'].forEach(dir => {
      const hdl = document.createElement('div');
      hdl.className = 'handle ' + dir;
      hdl.dataset.dir = dir;
      el.appendChild(hdl);
      hdl.addEventListener('mousedown', onResizeStart);
    });

    [['top','top'], ['right','right'], ['bottom','bottom'], ['left','left']]
      .forEach(([cls, side]) => {
        const port = document.createElement('div');
        port.className = 'port ' + cls;
        port.dataset.side = side;
        el.appendChild(port);
        port.addEventListener('mousedown', onPortDragStart);
      });

    shapesLayer.appendChild(el);
    nodes.set(id, { id, el, x, y, w, h });

    el.addEventListener('mousedown', onNodeDragStart);
    el.addEventListener('mousedown', setSelectedNode, true);

    return el;
  }

  function setSelectedNode(e) {
    const nodeEl = e.currentTarget;
    if (e.target.closest('.handle') || e.target.closest('.port')) return;
    if (e.target.isContentEditable) return;

    if (selectedNodeEl && selectedNodeEl !== nodeEl) {
      selectedNodeEl.classList.remove('selected');
    }
    selectedNodeEl = nodeEl;
    nodeEl.classList.add('selected');
    nodeEl.style.zIndex = String(++zCounter);
  }

  function clearSelection() {
    if (selectedNodeEl) {
      selectedNodeEl.classList.remove('selected');
    }
    selectedNodeEl = null;
  }

  // Drag node with grid snapping
  function onNodeDragStart(e) {
    const nodeEl = e.currentTarget;
    if (e.button !== 0) return;
    if (e.target.closest('.handle') || e.target.closest('.port')) return;
    if (e.target.isContentEditable) return;

    e.preventDefault();
    const id = Number(nodeEl.dataset.id);
    const node = nodes.get(id);
    const boardRect = board.getBoundingClientRect();
    const startMouse = { x: e.clientX, y: e.clientY };
    const start = { x: node.x, y: node.y };

    function onMove(ev) {
      const dx = ev.clientX - startMouse.x;
      const dy = ev.clientY - startMouse.y;
      const rawX = Math.max(0, Math.min(boardRect.width - node.w, start.x + dx));
      const rawY = Math.max(0, Math.min(boardRect.height - node.h, start.y + dy));
      const nx = snapToGrid(rawX);
      const ny = snapToGrid(rawY);
      node.x = nx;
      node.y = ny;
      nodeEl.style.left = nx + 'px';
      nodeEl.style.top = ny + 'px';
      updateEdgesForNode(node.id);
    }
    function onUp() {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // Resize node (snap size and position to grid)
  function onResizeStart(e) {
    e.stopPropagation();
    e.preventDefault();
    const handleEl = e.currentTarget;
    const dir = handleEl.dataset.dir;
    const nodeEl = handleEl.closest('.node');
    const id = Number(nodeEl.dataset.id);
    const node = nodes.get(id);
    const boardRect = board.getBoundingClientRect();
    const startMouse = { x: e.clientX, y: e.clientY };
    const start = { x: node.x, y: node.y, w: node.w, h: node.h };
    const minW = 120, minH = 60;

    function onMove(ev) {
      let dx = ev.clientX - startMouse.x;
      let dy = ev.clientY - startMouse.y;

      let nx = start.x;
      let ny = start.y;
      let nw = start.w;
      let nh = start.h;

      if (dir.includes('e')) {
        nw = Math.max(minW, Math.min(boardRect.width - start.x, start.w + dx));
      }
      if (dir.includes('s')) {
        nh = Math.max(minH, Math.min(boardRect.height - start.y, start.h + dy));
      }
      if (dir.includes('w')) {
        nw = Math.max(minW, start.w - dx);
        nx = start.x + (start.w - nw);
        nx = Math.max(0, Math.min(start.x + start.w - minW, nx));
      }
      if (dir.includes('n')) {
        nh = Math.max(minH, start.h - dy);
        ny = start.y + (start.h - nh);
        ny = Math.max(0, Math.min(start.y + start.h - minH, ny));
      }

      nx = snapToGrid(nx);
      ny = snapToGrid(ny);
      nw = Math.max(minW, snapToGrid(nw));
      nh = Math.max(minH, snapToGrid(nh));

      node.x = nx; node.y = ny; node.w = nw; node.h = nh;
      nodeEl.style.left = nx + 'px';
      nodeEl.style.top = ny + 'px';
      nodeEl.style.width = nw + 'px';
      nodeEl.style.height = nh + 'px';
      updateEdgesForNode(node.id);
    }

    function onUp() {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // Port drag to connect
  function onPortDragStart(e) {
    if (e.button !== 0) return;
    e.stopPropagation();
    e.preventDefault();
    const fromPortEl = e.currentTarget;
    linking.active = true;
    linking.fromPortEl = fromPortEl;

    const temp = document.createElementNS('http://www.w3.org/2000/svg','path');
    temp.setAttribute('class', 'connector temp arrow');
    svg.appendChild(temp);
    linking.tempPath = temp;

    function onMove(ev) {
      const p0 = getPortCenterLocal(fromPortEl);
      const mouseLocal = clientToLocal(ev.clientX, ev.clientY);
      const sideFrom = fromPortEl.dataset.side;
      // guess target direction
      const dx = mouseLocal.x - p0.x, dy = mouseLocal.y - p0.y;
      const sideTo = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'left' : 'right') : (dy > 0 ? 'top' : 'bottom');
      const pts = routeOrthogonal(p0, mouseLocal, sideFrom, sideTo);
      setPathPolyline(temp, pts);
    }

    function onUp(ev) {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);

      const targetEl = document.elementFromPoint(ev.clientX, ev.clientY);
      if (targetEl && targetEl.classList && targetEl.classList.contains('port') && targetEl !== fromPortEl) {
        const edge = createEdge(fromPortEl, targetEl);
        updateEdge(edge);
      }
      if (linking.tempPath && linking.tempPath.parentNode === svg) {
        svg.removeChild(linking.tempPath);
      }
      linking.active = false;
      linking.fromPortEl = null;
      linking.tempPath = null;
    }

    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  function createEdge(fromPortEl, toPortEl) {
    const fromNodeEl = fromPortEl.closest('.node');
    const toNodeEl = toPortEl.closest('.node');
    const edgeId = edgeIdCounter++;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class', 'connector arrow');
    path.dataset.id = String(edgeId);
    svg.appendChild(path);

    const edge = {
      id: edgeId,
      from: { nodeId: Number(fromNodeEl.dataset.id), side: fromPortEl.dataset.side },
      to: { nodeId: Number(toNodeEl.dataset.id), side: toPortEl.dataset.side },
      path
    };
    edges.set(edgeId, edge);
    return edge;
  }

  function updateEdge(edge) {
    const fromNode = nodes.get(edge.from.nodeId);
    const toNode = nodes.get(edge.to.nodeId);
    const fromPortEl = getPortEl(fromNode.el, edge.from.side);
    const toPortEl = getPortEl(toNode.el, edge.to.side);
    const p0 = getPortCenterLocal(fromPortEl);
    const p1 = getPortCenterLocal(toPortEl);
    const pts = routeOrthogonal(p0, p1, edge.from.side, edge.to.side);
    setPathPolyline(edge.path, pts);
  }

  function updateEdgesForNode(nodeId) {
    edges.forEach(edge => {
      if (edge.from.nodeId === nodeId || edge.to.nodeId === nodeId) {
        updateEdge(edge);
      }
    });
  }

  function getPortEl(nodeEl, side) {
    return nodeEl.querySelector(`.port.${side}`);
  }

  function clientToLocal(clientX, clientY) {
    const rect = board.getBoundingClientRect();
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function getPortCenterLocal(portEl) {
    const boardRect = board.getBoundingClientRect();
    const rect = portEl.getBoundingClientRect();
    return {
      x: rect.left - boardRect.left + rect.width / 2,
      y: rect.top - boardRect.top + rect.height / 2
    };
  }

  function dirVec(side) {
    switch (side) {
      case 'right': return { x: 1, y: 0 };
      case 'left': return { x: -1, y: 0 };
      case 'top': return { x: 0, y: -1 };
      case 'bottom': return { x: 0, y: 1 };
      default: return { x: 1, y: 0 };
    }
  }

  // Build orthogonal polyline with rounded joints (via stroke-linejoin: round)
  function routeOrthogonal(p0, p1, side0, side1) {
    const v0 = dirVec(side0);
    const v1 = dirVec(side1);

    // Exit and entry points
    const a = { x: p0.x + v0.x * ELBOW, y: p0.y + v0.y * ELBOW };
    const b = { x: p1.x + v1.x * ELBOW, y: p1.y + v1.y * ELBOW };

    // Primary route with 1 dogleg: horizontal-first or vertical-first depending on orientation
    let mid1, points;

    const horizontalFirst = Math.abs(p1.x - p0.x) >= Math.abs(p1.y - p0.y);

    if (horizontalFirst) {
      mid1 = { x: a.x, y: b.y };
      points = [p0, a, mid1, b, p1];
    } else {
      mid1 = { x: b.x, y: a.y };
      points = [p0, a, mid1, b, p1];
    }

    // Snap intermediate points to grid for tidy alignment
    points = points.map((pt, idx) => {
      // do not snap the last point to avoid jitter while dragging temp wire to mouse
      if (idx === points.length - 1 && linking.active && linking.tempPath) return pt;
      return { x: snapToGrid(pt.x), y: snapToGrid(pt.y) };
    });

    // Remove redundant colinear points
    points = dedupeColinear(points);

    return points;
  }

  function dedupeColinear(pts) {
    if (pts.length <= 2) return pts;
    const out = [pts[0]];
    for (let i = 1; i < pts.length - 1; i++) {
      const pPrev = out[out.length - 1];
      const p = pts[i];
      const pNext = pts[i + 1];
      const isColinear = (pPrev.x === p.x && p.x === pNext.x) || (pPrev.y === p.y && p.y === pNext.y);
      if (!isColinear) out.push(p);
    }
    out.push(pts[pts.length - 1]);
    return out;
  }

  function setPathPolyline(pathEl, points) {
    const d = points.map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`)).join(' ');
    pathEl.setAttribute('d', d);
  }

  // Click-empty to clear selection
  board.addEventListener('mousedown', (e) => {
    if (e.target === board || e.target === svg) {
      clearSelection();
    }
  });

  // Buttons
  addBlockBtn.addEventListener('click', () => {
    const { width, height } = board.getBoundingClientRect();
    const x = 60 + Math.random() * (width - 260);
    const y = 60 + Math.random() * (height - 220);
    const el = createNode(x, y);
    const id = Number(el.dataset.id);
    const node = nodes.get(id);
    node.x = snapToGrid(x); node.y = snapToGrid(y); node.w = el.offsetWidth; node.h = el.offsetHeight;
  });

  addTwoBtn.addEventListener('click', () => {
    const { width, height } = board.getBoundingClientRect();
    const n1El = createNode(120, 120, 216, 120, 'Начало');
    const n2El = createNode(Math.min(width - 360, 520), Math.min(height - 260, 280), 240, 140, 'Действие');
    const n1 = nodes.get(Number(n1El.dataset.id));
    const n2 = nodes.get(Number(n2El.dataset.id));
    n1.x = snapToGrid(120); n1.y = snapToGrid(120); n1.w = n1El.offsetWidth; n1.h = n1El.offsetHeight;
    n2.x = snapToGrid(Math.min(width - 360, 520));
    n2.y = snapToGrid(Math.min(height - 260, 280));
    n2.w = n2El.offsetWidth; n2.h = n2El.offsetHeight;

    const from = n1El.querySelector('.port.right');
    const to = n2El.querySelector('.port.left');
    const e = createEdge(from, to);
    updateEdge(e);
  });

  // Fit SVG coordinate size to board
  function resizeSvgToBoard() {
    const { width, height } = board.getBoundingClientRect();
    svg.setAttribute('width', String(width));
    svg.setAttribute('height', String(height));
  }
  window.addEventListener('resize', () => { resizeSvgToBoard(); edges.forEach(updateEdge); });

  // Init
  resizeSvgToBoard();
  addTwoBtn.click();
})();
</script>
</body>
</html>
